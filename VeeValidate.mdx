# Why vee-validate

"Forms" is a difficult subject in frontend development. Not only do you have to deal with ensuring that correct values are submitted, but you should also provide a pleasant UX for your users.

Building forms from scratch is a lot of work and you probably won't cover all your future needs as your requirements change over time, and as you add more features.

**The time you spend working on a custom form solution is better spent building your application logic**.

Most form libraries will save you a lot of time, but `vee-validate` tackles the major pain points of forms and then gets out of your way, some of those are:

- Form state and value tracking
- UX
- Synchronous and Asynchronous Validation
- Handling submissions

vee-validate tries to handle all of the above and more by providing abstractions to these problems without any UI. This could be viewed as a double-edged sword, however, overriding UI and styles was the downfall of many component libraries and design languages.

Because of that, vee-validate abstracts away the hard parts into pure logic compositions that you can add to your existing UI and component. There is nothing to override, there is no hidden cost. You can also use vee-validate to power your components internally, and as a result you can build up your form library without having to think about the hard parts.

A great showcase of this approach is how vee-validate seamlessly [integrate with almost every component UI library](/examples/ui-libraries/) for Vue.js out there without any special treatment or hacks.

## Getting Started

vee-validate makes use of two flavors to add validation to your forms.

- **Composition API**: This is the best way to use vee-validate as it allows seamless integrations with your existing UI, or any 3rd party component library.
- **Higher-order components (HOC)**: This approach is easy to use and is strictly used within the template, you can use it if you have simple forms and don't want to write a lot of JavaScript.

Whichever approach you prefer to use, both flavors can be used interchangeably. So you can mix and match between the two approaches as needed.

<DocTip title="Setup SFC">

Most examples in the docs use the new [script setup](https://vuejs.org/api/sfc-script-setup.html#script-setup) SFC syntax for brevity. In case you're having difficulty following along, take some time to learn about it.

</DocTip>

### Using a package manager

For a more modern workflow with a bundler, you can install vee-validate using a package manager like `yarn`, `npm` or `pnpm`:

```sh
yarn add vee-validate
# or
npm i vee-validate --save
# or
pnpm add vee-validate
```

### Using a script tag

You can use vee-validate with a script tag and a CDN, import the library like this:

```html
<script src="https://unpkg.com/vee-validate"></script>
```

This will inject a `VeeValidate` global object, which you will use to access the various components and functions exposed by vee-validate.

# Best Practices

## Displaying Errors

vee-validate may choose to display form errors if they already existed before the form is mounted, at any case it is a good practice to explicitly define when should an error message appear.

For example it could a good idea to display the message if the field is `touched`:

```vue
<template>
  <div>
    <input name="fieldName" v-model="value" />
    <span v-if="errorMessage && meta.touched">
      {{ errorMessage }}
    </span>
  </div>
</template>

<script setup>
import { useField } from 'vee-validate';

const { errorMessage, meta, value } = useField('fieldName');
</script>
```

This ensures the fields are not aggressive towards the user.

## Yup Bundle Size

vee-validate's entire core size is very small, but the same can't be said about the validators you import. Most examples use the following snippet to import everything `yup` has to offer:

```js
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().email(),
  // ...
});
```

You should leverage your bundler's tree-shaking capabilities and only import what you need:

```js
import { object, string } from 'yup';

const schema = object({
  email: string().email(),
  // ...
});
```

This will keep your app bundle size and routes to a minimum, ensuring faster load and interaction experiences for your users.

# Validation

vee-validate handles complex validations in a very easy way, it supports synchronous and asynchronous validation and allows defining rules on the field-level or the form level using validation schemas with built-in support for [yup](https://github.com/jquense/yup).

You will be using the following components to validate your forms:

- A `Field` component represents a single form input and can be used to render any kind of HTML elements or Vue components.
- A `Form` component that renders a form. Do not confuse the `<Form>` tag with the HTML `<form>` tag.
- An `ErrorMessage` component that displays an error message for a field, you don't have to use it as there are many ways to render error messages.

Here is the most simple example in action:

<p
  class="codepen"
  data-height="265"
  data-theme-id="light"
  data-default-tab="js,result"
  data-user="logaretm"
  data-slug-hash="rNxbMzq"
  style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"
  data-pen-title="Basic Example"
>
  <span>
    See the Pen <a href="https://codepen.io/logaretm/pen/rNxbMzq">Basic Example</a> by Abdelrahman Awad (
    <a href="https://codepen.io/logaretm">@logaretm</a>) on <a href="https://codepen.io">CodePen</a>.
  </span>
</p>

<DocTip>

From this point forwards, the docs will assume basic knowledge of [Vue's SFC components](https://v3.vuejs.org/guide/single-file-component.html) and will demonstrate examples as such and will be using ES6+ code snippets. So be sure to brush up on these if you haven't already.

</DocTip>

## Field-level Validation

You can define validation rules for your fields using the `Field` component, your rules can be as simple as a function that accepts the current value and returns an error message.

```vue
<template>
  <Form>
    <Field name="field" :rules="isRequired" />
    <ErrorMessage name="field" />
  </Form>
</template>

<script setup>
import { Field, Form, ErrorMessage } from 'vee-validate';

function isRequired(value) {
  if (value && value.trim()) {
    return true;
  }

  return 'This is required';
}
</script>
```

### Validating fields with yup

[`yup`](https://github.com/jquense/yup) is a very popular, simple and powerful data validation library for JavaScript, you can use it in combination with vee-validate, You can use `yup` to define your validation rules for that field:

```vue{3,10,20}
<template>
  <Form>
    <Field name="password" type="password" :rules="passwordRules" />
    <ErrorMessage name="password" />
  </Form>
</template>

<script setup>
import { Field, Form, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const passwordRules = yup.string().required().min(8);
</script>
```

For more information on the `Field` component, read [the API reference](/api/field).

## Form-level Validation

vee-validate supports using a validation schema to define all your validations on your fields beforehand so you don't have to define them individually on your fields.
Form-level validation is convenient if you are building large forms and want to keep your templates cleaner.

A simple validation schema can be an object containing field names as keys and validation functions as the value for those keys:

```vue
<template>
  <Form @submit="submit" :validation-schema="simpleSchema">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';

const simpleSchema = {
  email(value) {
    // validate email value...
  },
  name(value) {
    // validate name value...
  },
  // If you defined global rules you can also use them
  password: 'required|min:8',
  // ...
};
</script>
```

### Validation schemas with yup

Fortunately there is already a very neat way to build validation schemas for your forms by using `yup`, it allows you create validation objects like this:

```js
const schema = yup.object({
  email: yup.string().required().email(),
  name: yup.string().required(),
  password: yup.string().required().min(8),
});
```

vee-validate has built-in support for yup schemas, You can pass your schemas to the `<Form />` component using the `validation-schema` prop:

```vue
<template>
  <Form @submit="submit" :validation-schema="schema">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});
</script>
```

For more information on the `Form` component, read [the API reference](/api/form).

<DocTip title="Yup Schema Optimizations" type="warn">

There are a couple of optimization caveats when it comes to using `yup` schemas to validate your forms, be sure to check the [best practices guide](/guide/best-practices).

</DocTip>

<DocTip title="Zod Schema Plugin">

There is an official integration available for [Zod validation](https://github.com/colinhacks/zod) that you can use as a drop-in replacement for `yup`. Check the [zod integration page](/integrations/zod-schema-validation).

</DocTip>

### Reactive Form Schema

You can have reactive form schemas using `computed` if you are looking to create dynamic schemas using either `yup` or a validation object.

```js
import * as yup from 'yup';

export default {
  data: () => ({
    min: 6,
  }),
  computed: {
    schema() {
      return yup.object({
        password: yup.string().min(this.min),
      });
    },
  },
};
```

```vue
<template>
  <Form @submit="submit" :validation-schema="schema">
    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

export default {
  components: {
    Form,
    Field,
    ErrorMessage,
  },
  data: () => ({
    min: 6,
  }),
  computed: {
    schema() {
      return yup.object({
        password: yup.string().min(this.min),
      });
    },
  },
};
</script>
```

When the validation schema changes, only the fields that were validated at least once will be re-validated, the other fields won't be validated to avoid aggressive validation behavior.

## Validation Behavior

By default vee-validate runs validation in these scenarios:

**After field value change**

- When a `change` event is dispatched/emitted
- value changed externally (model update or others)

Note that `input` event is not considered to be a trigger because it would make it too aggressive, you can configure the triggers in the next section to suit your needs.

**After Rules change**

- Only if the field was validated before via user interaction

**After field is blurred**

- Field has been blurred (`blur` event was emitted)

**After form submissions**

- When the form has been submitted with either `handleSubmit` or `submitForm` on the `<Form />` component slot props

### Customizing Validation Triggers

By default vee-validate adds multiple event listeners to your fields:

- **input:** Adds a `handleChange` handler that updates the field value, and it may validate if configured to do so (may update `meta.dirty` flag if the value changed).
- **change:** Adds a `handleChange` handler that updates the field value and validates the field (may update `meta.dirty` flag if the value changed).
- **blur:** Adds a `handleBlur` handler that updates the `meta.touched` flag.
- **update:modelValue** Adds a `handleChange` handler to components emitting the `update:modelValue` event

Notice that in all of these, the `handleChange` handler is the only one that triggers validation. You can configure if a handler should validate by using the `configure` helper:

```js
import { configure } from 'vee-validate';

// Default values
configure({
  validateOnBlur: true, // controls if `blur` events should trigger validation with `handleChange` handler
  validateOnChange: true, // controls if `change` events should trigger validation with `handleChange` handler
  validateOnInput: false, // controls if `input` events should trigger validation with `handleChange` handler
  validateOnModelUpdate: true, // controls if `update:modelValue` events should trigger validation with `handleChange` handler
});
```

Note that configuring any of these options to `false` will not remove all the events, they only control if each event triggers a validation check or not.

This might not be flexible enough for your needs, which is why you can define the same config per `Field` component instance:

```vue-html
<!-- Turns off validation events -->
<Field name="email" :validateOnBlur="false" :validateOnChange="false" :validateOnInput="false" />
```

Additionally if you need to use different events or have specific needs in mind, you can control which events to listen to by using the scoped-slot `handleChange` prop of the `<Field />` component and binding it to the desired event:

```vue-html
<!-- Listen to all events, this is the default behavior -->
<Field v-slot="{ field }">
  <input v-bind="field" />
</Field>

<!-- Only validate when the change event is dispatched -->
<Field v-slot="{ field, handleChange }">
  <input @change="handleChange" :value="field.value" />
</Field>
```

In addition to those events, you can also validate when the `<Field />` or `<Form />` components are mounted with `validateOnMount` prop present on both components:

```vue-html
<!-- Trigger validation when this field is mounted (initial validation) -->
<Field name="name" validate-on-mount />

<!-- Trigger validation on all fields inside this form when the form is mounted -->
<Form validate-on-mount>
  <Field name="email" />
  <Field name="password" />
</Form>
```

You can also specify if a `handleChange` call should trigger validation or not by providing the second argument:

```vue-html
<!-- Only update field value without validating it -->
<Field v-slot="{ field, handleChange }">
  <input @change="$event => handleChange($event, false)" :value="field.value" />
</Field>
```

<DocTip title="Vue components validation triggers">

When applying `v-bind="field"` to a Vue component, be careful that the listeners will both be applied for Vue and native DOM events, meaning you might trigger validation unintentionally.

An example of that could be `input[type="file"]` inputs, because you cannot bind the `value` attribute to a file instance which means two-way binding won't work there. In that case, only listing to handful of events makes more sense:

```vue-html
<Field name="file" v-slot="{ handleChange, handleBlur }">
  <input type="file" @change="handleChange" @blur="handleBlur" />
</Field>
```

For custom components, it is recommended that you listen to the proper events when using `v-bind` with custom components, the following sample uses `modelValue` events.

```vue-html
<Field name="custom" v-slot="{ handleChange, value }">
  <CustomInput :modelValue="value" @update:modelValue="handleChange" />
</Field>
```

For 3rd party components you may consult their documentation to figure which events to trigger validation for. Here are a few examples for the common UI frameworks [here](/examples/ui-libraries).

</DocTip>

## Displaying Error Messages

### Using the Field slot-props

If you intend to use the scoped slot on the `Field` component, you can access `errors` or `errorMessage` on the scoped slot props to render your messages:

```vue-html
<Field name="field" :rules="rules" v-slot="{ field, errors, errorMessage }">
  <input v-bind="field" type="text" />
  <span>{{ errors[0] }}</span>
  <!-- Or -->
  <span>{{ errorMessage }}</span>
</Field>
```

This is convenient if you have a complex markup for your input and would like to keep everything contained within, it also allows you to create input components with built-in validation.

### Using the Form slot-props

As you noticed the `<Form />` component gives you access to the `errors` on its scoped-slot props which you can use to display any error messages for any `<Field />` within that form:

```vue-html
<Form v-slot="{ errors }">
  <Field name="field" :rules="rules" />
  {{ errors.field }}
</Form>
```

and if you would like, you could display all error messages for your fields by iterating over the `errors` object:

```vue-html
<Form v-slot="{ errors }">
  <template v-if="Object.keys(errors).length">
    <p>Please correct the following errors</p>
    <ul>
      <li v-for="(message, field) in errors" :key="field">
        {{ message }}
      </li>
    </ul>
  </template>

  <Field name="name" :rules="rules" />
  <Field name="email" :rules="rules" />
  <Field name="password" :rules="rules" />
</Form>
```

### Using ErrorMessage component

You've seen how the `ErrorMessage` works in the previous examples, by default the `ErrorMessage` component renders a `span` but you can specify any kind of HTML element or global component to the `as` prop.

```vue-html
<Form>
  <Field name="field" :rules="rules" />
  <!-- Render the error message as a div element -->
  <ErrorMessage name="field" as="div" />
</Form>
```

The `<ErrorMessage />` component is very flexible and you can customize its render output with scoped slots to build complex messages markup, read the [ErrorMessage API reference](/api/error-message) for more information.

### Custom Field Labels

More often than not, your fields will have names with underscores or shorthands which isn't very nice when showing in error messages, for example, you might have specific encoding to your field names because they might be generated by the backend. Ideally, you want to avoid having messages like:

```txt
The down_p is required
```

And instead, show something more meaningful to the user

```txt
The down payment is required
```

You can do this in two ways depending on which validators you are using (yup or [global validators](/guide/global-validators)).

With yup it is very straightforward, you just need to call `label()` after defining your field's validations either in field level or form level:

```js
const schema = Yup.object({
  email_addr: Yup.string().email().required().label('Email Address'),
  acc_pazzword: Yup.string().min(5).required().label('Your Password'),
});
```

Here is a live example:

<LiveExample client:visible id="vee-validate-v4-friendly-labels-with-yup" />

If you are interested in how to do the same for global validators check the [i18n guide](/guide/i18n#custom-labels)

## Validation Metadata

### Field-level Meta

Each field has metadata associated with it, the `meta` property available on the `<Field />` component contains additional information about the field:

- `valid`: The current field validity, automatically updated for you.
- `touched`: If the field was blurred (unfocused), can be updated with the `handleBlur` function or `setTouched` on the field's slot scope props.
- `dirty`: If the field value was updated, you cannot change its value.
- `pending`: If the field's validations are still running, useful for long-running async validation.
- `initialValue`: The field's initial value, is `undefined` if you didn't specify any.

```vue-html
<Field name="email" type="email" :rules="validateEmail" v-slot="{ field, meta }">
  <input v-bind="field" />
  <pre>{{ meta }}</pre>
</Field>
```

This is the typescript interface for a field's meta-object value

```ts
interface FieldMeta {
  dirty: boolean;
  pending: boolean;
  touched: boolean;
  valid: boolean;
  initialValue: any;
}
```

<DocTip title="Field Dirty Flag and Initial Values">
  
The default value is `undefined` unless specified which may cause unexpected `meta.dirty` results. To get accurate results for the `meta.dirty` flag, you must provide an initial value to your field even if the values are empty.

```vue-html
<Field name="email" value="" type="email" v-slot="{ field, meta }">
  <input v-bind="field" />
  <pre>{{ meta }}</pre>
</Field>
```

To reduce the verbosity of adding a `value` prop to each field, you could provide the `initial-values` prop to your `<Form />` component instead.

</DocTip>

<DocTip title="Valid Flag Combinations">
  
Since the `meta.valid` flag is initially `true` (because it just means there are no errors yet), it would cause problems if you have a "success" UI state an indicator.

To avoid this case you could combine the `valid` flag with either `meta.dirty` or `meta.touched` to get accurate representation:

```vue-html
<Field name="email" type="email" :rules="validateEmail" v-slot="{ field, errorMessage, meta }">
  <input v-bind="field" />
  <span v-if="errorMessage">⛔️ {{ errorMessage }}</span>
  <span v-if="meta.valid && meta.touched">✅ Field is valid</span>
</Field>
```

</DocTip>

### Form-level Meta

Forms also have their own `meta` value containing useful information about the form, it is an aggregation of the metadata for the fields inside that form.

The form's metadata properties are:

- `valid`: The form's validity status, will be `true` if the errors array is empty. After the form is mounted, vee-validate will update the flag to its accurate state
- `touched`: If at least one field was blurred (unfocused) inside the form.
- `dirty`: If at least one field's value was updated.
- `pending`: If at least one field's validation is still pending.
- `initialValues`: All fields' initial values, packed into an object where the keys are the field names.

```vue-html
<Form v-slot="{ meta }">
  <!-- Some fields -->
  <pre>{{ meta }}</pre>
</Form>
```

Here is a similar example where we disable the form's submit button if no value was changed, we will check the `dirty` flag on the form's scoped slot props which should tell us if the form values have changed or not.

```vue
<template>
  <Form v-slot="{ meta }" :initial-values="initialValues">
    <Field name="email" />

    <button :disabled="!meta.dirty">Submit</button>
  </Form>
</template>

<script>
import { Field, Form } from 'vee-validate';

export default {
  components: {
    Field,
    Form,
  },
  data() {
    return {
      initialValues: { email: '' },
    };
  },
};
</script>
```

<DocTip title="Form Dirty Flag and Initial Values">
  
Notice that the `initial-values` in the previous example were provided, like mentioned for the `meta.dirty` accuracy for fields, to get accurate results for the `meta.dirty` flag, you must provide initial values to your forms even if the values are empty.

</DocTip>

<DocTip title="Valid Flag Combinations">
  
Forms `meta.valid` flag is also initially `true` (because it just means there are no errors yet), it would cause problems if you have a "success" UI state or an indicator.

To avoid this case you could combine the form's `valid` flag with either `meta.dirty` or `meta.touched` to get accurate representation:

```vue-html
<Form v-slot="{ meta, errors }">
  <Field name="email" type="email" :rules="validateEmail" />
  <span v-if="errors.email">⛔️ {{ errors.email }}</span>
  <span v-if="meta.valid && meta.touched">✅ Form is valid</span>
</Form>
```

</DocTip>

# Handling Forms

vee-validate offers many helpers to handle form submissions, resets, and DX to make your forms much easier to reason about and less of a burden to maintain. The `Form` component handles the following form cases:

<div class="features">

- Submitting forms with JavaScript listeners (AJAX)
- Submitting forms using the classic/native approach (page reload)
- Handling form resets

</div>

## Form Values

So far you probably noticed we didn't use `v-model` once in the examples. This is because in most cases you don't need the model values until you submit them to your API or not at all if you are submitting an HTML form without JavaScript.

Having to create models just to be able to reference them later is redundant and vee-validate goes around this by creating an internal model for the `<Field />` field component instances and tracks them and keeps them in sync with the input. You can still use `v-model` if you need it but vee-validate doesn't require it.

You may access your form's values using the `values` scoped slot prop on the `Form` component:

```vue
<template>
  <Form v-slot="{ values }">
    <Field name="email" type="email" />
    <Field name="password" type="password" />

    <!-- print form values -->
    <pre>{{ values }}</pre>
  </Form>
</template>

<script setup>
import { Form, Field } from 'vee-validate';
</script>
```

You will rarely need to access the form values inside the template, but it is there if you ever need it. What's interesting is that vee-validate follows the assumption that most likely you will need the form values at the submission phase.

So if you were to add a `submit` handler on the `<Form />` component, vee-validate will automatically pass the form values to your handler as the first argument.

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <Field name="email" type="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});

function onSubmit(values) {
  // Submit values to API...
  alert(JSON.stringify(values, null, 2));
}
</script>
```

## Handling Submissions

vee-validate exposes useful defaults to help you handle form submissions whether you submit them using JavaScript or native HTML submissions, in most cases, you would like to make sure all your fields are valid before you submit the form, this is done for you by default.

Consider the last example, if you tried submitting the form, it won't be submitted unless all fields are valid. When rendering a form using the `as` prop, vee-validate will automatically listen for the `submit` event and prevent the execution of any `submit` listener you may have on the form.

If you have a `submit` listener on the `Form` component, vee-validate assumes you will be handling submissions via JavaScript (AJAX) and automatically calls `event.preventDefault()` for you and once the form is finished validating and turned out to be valid it will pass all the values of the `<Field />` components.

But in the case when you don't have a `submit` listener on your form, vee-validate assumes that the form will be submitted using the native HTML submission that causes the page to "reload". However vee-validate will make sure the form is not submitted unless all fields are valid, here is an example:

```vue-html
<Form method="post" action="/api/users" :validation-schema="schema" />
  <Field name="email" />
  <Field name="name" type="email" />
  <Field name="password" type="password" />

  <button>Submit</button>
</Form>
```

## Manually Handling Submissions

If you have complex markup requirements in your forms, you can use any of those `<Form />` component slot props:

- `handleSubmit`: automatically prevents native submission at all times, use for AJAX submissions
- `submitForm`: prevents native submissions as long as the form is invalid, use for native submissions
- `validate`: triggers validation on all fields belonging to the form

### Using handleSubmit

The `handleSubmit` slot prop is probably the most common method you will use to handle form submissions manually, it accepts a callback that will be executed with the form values if the form is valid.

```vue
<template>
  <VeeForm v-slot="{ handleSubmit }" :validation-schema="schema" as="div">
    <form @submit="handleSubmit($event, onSubmit)">
      <Field name="email" type="email" />
      <ErrorMessage name="email" />

      <Field name="password" type="password" />
      <ErrorMessage name="password" />

      <button>Submit</button>
    </form>
  </VeeForm>
</template>

<script setup>
import { Form as VeeForm, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});

function onSubmit(values) {
  // Submit values to API...
  alert(JSON.stringify(values, null, 2));
}
</script>
```

### Using submitForm

Alternatively if you plan to submit forms natively which will cause a page "reload" then use `submitForm` as an event handler:

```vue
<template>
  <VeeForm v-slot="{ submitForm }" :validation-schema="schema" as="div">
    <form @submit="submitForm" method="post" action="/api/users/">
      <Field name="email" type="email" />
      <ErrorMessage name="email" />

      <Field name="password" type="password" />
      <ErrorMessage name="password" />

      <button>Submit</button>
    </form>
  </VeeForm>
</template>

<script setup>
import { Form as VeeForm, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});
</script>
```

This will prevent submitting the form until all fields are valid.

### Using validate()

You can validate the form without submissions using the `validate()` slot prop function:

```vue-html
<Form v-slot="{ validate }" :validation-schema="schema">
  <Field name="email" type="email" />
  <ErrorMessage name="email" />

  <Field name="password" type="password" />
  <ErrorMessage name="password" />

  <button type="button" @click="validate">Submit</button>
</Form>
```

That form doesn't render a `form` tag, so vee-validate doesn't handle submissions for that group of fields. But you can still validate them using the `validate` function present on the `Form` component slot props.

## Submission Progress

Quite often you need to show your users a submission indicator, or you might want to disable the submit button entirely until the submission attempt is done. The `Form` component offers an `isSubmitting` slot prop that you can use to show such UI indicators.

The `isSubmitting` state will be set to `true` once the validation of the form starts (as a result of a submit event) and will keep track of the submission handler you passed to either `onSubmit` or until it calls `submitForm`. If the submission handler throws any errors or completes successfully it will be set to `false` afterward.

Here is small example:

<p
  class="codepen"
  data-height="265"
  data-theme-id="light"
  data-default-tab="html,result"
  data-user="logaretm"
  data-slug-hash="xxVZOGX"
  style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"
  data-pen-title="vee-validate v4 isSubmitting"
>
  <span>
    See the Pen <a href="https://codepen.io/logaretm/pen/xxVZOGX">vee-validate v4 isSubmitting</a> by Abdelrahman Awad (
    <a href="https://codepen.io/logaretm">@logaretm</a>) on <a href="https://codepen.io">CodePen</a>.
  </span>
</p>

<DocTip title="isSubmitting and validate()">

Note that calling `validate` from the `Form` slot props will not cause the `isSubmitting` state to change, it will only change if either `submitForm` or `handleSubmit` are called or when a submit event is triggered.

</DocTip>

<DocTip title="submitCount">

The `Form` component exposes a `submitCount` state that you can use to track the number of submission attempts done by the user. For more information check the [API Reference](/api/form).

</DocTip>

## Handling Invalid Submissions

In case you want to perform some logic after a form fails to submit due to validation errors (e.g: focusing the first invalid field), you can listen for the `onInvalidSubmit` event emitted by the `<Form />` component.

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema" @invalid-submit="onInvalidSubmit">
    <Field name="email" type="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});

function onSubmit(values) {
  // Submit values to API...
  alert(JSON.stringify(values, null, 2));
}

function onInvalidSubmit({ values, errors, results }) {
  console.log(values); // current form values
  console.log(errors); // a map of field names and their first error message
  console.log(results); // a detailed map of field names and their validation results
}
</script>
```

Specifying a `onInvalidSubmit` prop or `@invalid-submit` will run your handler if you submit your form using either `handleSubmit` or the regular form submit event but not the `submitForm` function.

## Initial Values

Since with vee-validate you don't have to use `v-model` to track your values, the `Form` component allows you to define the starting values for your fields, by default all fields start with `undefined` as a value.

Using the `initialValues` prop you can send an object that contains the field names as keys and their values:

```vue
<template>
  <Form :validation-schema="schema" :initial-values="formValues">
    <Field name="email" type="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button type="Submit">Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});

// Initial values
const formValues = {
  email: 'example@example.com',
  password: 'P@$$w0Rd',
};
</script>
```

Doing so will trigger initial validation on the form and it will generate messages for fields that fail the initial validation. You can still use `v-model` on your fields to define model-based initial values.

You can use `validateOnMount` prop present on the `<Form />` component to force an initial validation when the component is mounted.

Note that **only the non-dirty fields will be updated**. In other words, **only the fields that were not manipulated by the user will be updated**. For information on how to set the values for all fields regardless of their dirty status check the following [Setting Form Values section](#setting-form-values)

<DocTip>

It's generally recommended that you provide the `initialValues`, this is because vee-validate cannot assume a reasonable initial value for your fields other than `undefined` which may cause unexpected behavior when using a 3rd-party validator that does not deal with `undefined`.

</DocTip>

## Setting Form Values

You can set any field's value using either `setFieldValue` or `setValues`, both methods are exposed on the `<Form />` component scoped slot props, and as component instance methods.

You can call them with template `$refs` and for an added convenience you can call them in the submit handler callback.

**Using scoped slot props**

```vue-html
<Form v-slot="{ setFieldValue, setValues }">
  <Field name="email"  />
  <ErrorMessage name="email" />

  <Field name="password"  />
  <ErrorMessage name="password" />

  <button type="button" @click="setFieldValue('email', 'test')">Set Field Value</button>
  <button type="button" @click="setValues({ email: 'test', password: 'test12' })">
    Set Multiple Values
  </button>
</Form>
```

**Using submit callback**

```vue
<template>
  <Form @submit="onSubmit">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values, actions) {
  // Submit the values...

  // set single field value
  actions.setFieldValue('email', 'ummm@example.com');

  // set multiple values
  actions.setValues({
    email: 'ummm@example.com',
    password: 'P@$$w0Rd',
  });
}
</script>
```

**Using template `$refs`**

```vue
<template>
  <Form @submit="onSubmit" ref="myForm">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values) {
  // Submit the values...

  // set single field value
  this.$refs.myForm.setFieldValue('email', 'ummm@example.com');

  // set multiple values
  this.$refs.myForm.setValues({
    email: 'ummm@example.com',
    password: 'P@$$w0Rd',
  });
}
</script>
```

Note that setting any field's value using this way will trigger validation

## Submission Behavior

vee-validate does the following when you submit a form rendered by `<Form />` or when calling either `handleSubmit` or `submitForm`:

### Before validation stage

- Sets all fields `touched` meta to `true`
- Sets `isSubmitting` form state to `true`
- Increments the `submitCount` form state by `1`

### Validation stage

- Sets form and individual fields meta `pending` to `true` to indicate validation is in progress
- Runs the validation function/schema/rule against the current form values asynchronously
- Checks for any errors in the validation result
  - If there are errors then it will skip the next stage and update the validation state (meta, errors) for the form and fields
  - If there aren't any errors then it will set the `pending` meta flag to `false` and proceed to the next stage

### After validation stage

- Calls the `@submit` handler you specified, or calls the `handleSubmit` callback you provided.
- After the callbacks in either method finish (it will wait if the result is asynchronous), then it will set `isSubmitting` to `false`

Note that there isn't a need to have `isSubmitting` set back to false if you've used `submitForm`, as this submission method will perform a full-page refresh (native forms behavior).

## Handling Resets

vee-validate also handles form resets in a similar way to submissions. When resetting the form, all fields' errors and meta flags will be reset to their original state, including the fields' values.

Form reset is handled automatically if you are using the `as` prop to render a `form` element, like shown in this example:

```vue
<template>
  <Form :validation-schema="schema">
    <Field name="email" type="email" />
    <ErrorMessage name="email" />

    <Field name="password" type="password" />
    <ErrorMessage name="password" />

    <button type="Submit">Submit</button>
    <button type="reset">Reset</button>
  </Form>
</template>

<script setup>
import { Form, Field } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
  password: yup.string().required().min(8),
});
</script>
```

Alternatively if you plan to use the scoped slot for complex markup, you can use the `handleReset` slot prop function to trigger the reset manually:

```vue-html
<Form v-slot="{ handleReset }" :validation-schema="schema">
  <Field name="email" type="email" />
  <ErrorMessage name="email" />

  <Field name="password" type="password" />
  <ErrorMessage name="password" />

  <button type="button" @click="handleReset">Reset</button>
</Form>
```

### Resetting Forms After Submit

Usually you will reset your forms after a successful submission, the `onSubmit` handler receives an additional `FormActions` object in the second argument that allows you do some actions on the form after submissions, this is the shape of the `FormActions` object:

```ts
export interface FormActions {
  setFieldValue: (field: T, value: any) => void;
  setFieldError: (field: string, message: string | undefined) => void;
  setErrors: (fields: Partial<Record<string, string | undefined>>) => void;
  setValues: (fields: Partial<Record<T, any>>) => void;
  setFieldTouched: (field: string, isTouched: boolean) => void;
  setTouched: (fields: Partial<Record<string, boolean>>) => void;
  resetForm: (state?: Partial<FormState>) => void;
}
```

This is an example of using the form actions object to reset the form:

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <!-- fields ... -->
  </Form>
</template>

<script setup>
import { Form, Field } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  // ...
});

function onSubmit(values, { resetForm }) {
  console.log(values); // send data to API
  // reset the form and the field values to their initial values
  resetForm();
}
</script>
```

The `resetForm` accepts an optional `state` object that allows you to specify the new initial values for any of the fields state, this is the shape of the `FormState` object:

```ts
interface FormState {
  // any error messages
  errors: Record<string, string>;
  // dirty meta flags
  dirty: Record<string, boolean>;
  // touched meta flags
  touched: Record<string, boolean>;
  // Form Values
  values: Record<string, any>;
}
```

In the following snippet, `resetForm` is used to update the form values to specific ones other than their original values. This is useful if your receive your form state asynchronously

```js
resetForm({
  values: {
    email: 'example@example.com',
    password: '',
  },
});
```

You can also use template `$refs` to reset the form whenever you need:

```vue
<template>
  <Form ref="form" @submit="onSubmit" :validation-schema="schema">
    <!-- fields ... -->

    <button type="Submit">Submit</button>
  </Form>
</template>

<script setup>
import { Form, Field } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  // ...
});

function onSubmit(values) {
  console.log(values); // send data to API

  // reset the form
  this.$refs.form.resetForm();
}
</script>
```

## Initial Errors

If you are building a non-SPA application it is very common to pre-fill form errors using server-side rendering, frameworks like Laravel make this very easy to do. vee-validate supports filling the errors initially before any validation is done using the `initialErrors` prop which is present on the `<Form />` component scoped slot props.

The `initialErrors` property accepts an object containing the field names as keys with their corresponding error message string.

```vue
<template>
  <Form :initial-errors="initialErrors">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
const initialErrors = {
  email: 'This email is already taken',
  password: 'The password is too short',
};
</script>
```

<DocTip>

`initialErrors` are applied once the `Form` component is mounted and is ignored after, so any changes to the `initialErrors` props won't affect the messages.

See the next section for setting errors manually.

</DocTip>

## Setting Errors Manually

Quite often you will find yourself unable to replicate some validation rules on the client-side due to natural limitations. For example, `unique` email validation is complex to implement on the client-side, which is why the `<Form />` component allows you to set errors manually.

You can set messages for fields by using either `setFieldError` which sets an error message for one field at a time, and the `setErrors` function which allows you to set error messages for multiple fields at once.

Both functions are available on the `Form` component scoped slot props, and also on the `Form` component instance which enables you to use it with template `$refs`, and also for added convenience on the `submit` event handler since it would be the most common place for its usage.

Here are a few snippets showcasing its usage in these various scenarios:

**Using scoped slot props (recommended)**

```vue-html
<Form v-slot="{ setFieldError, setErrors }">
  <Field name="email"  />
  <ErrorMessage name="email" />

  <Field name="password"  />
  <ErrorMessage name="password" />

  <button type="button" @click="setFieldError('email', 'nope')">Set Single Error</button>
  <button type="button" @click="setErrors({ email: 'nope', password: 'wrong' })">
    Set Multiple Errors
  </button>
</Form>
```

**Using submit callback (recommended)**

```vue
<template>
  <Form @submit="onSubmit">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values, actions) {
  // Submit the values...

  // set single field error
  actions.setFieldError('email', 'this email is already taken');

  // set multiple errors
  actions.setErrors({
    email: 'this field is already taken',
    password: 'someone already has this password',
  });
}
</script>
```

**Using template `$refs`**

```vue
<template>
  <Form @submit="onSubmit" ref="myForm">
    <Field name="email" />
    <ErrorMessage name="email" />

    <Field name="password" />
    <ErrorMessage name="password" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values) {
  // Submit the values...

  // if API returns errors
  this.$refs.myForm.setFieldError('email', 'this email is already taken');
  this.$refs.myForm.setErrors({
    email: 'this field is already taken',
    password: 'someone already has this password',
  });
}
</script>
```

<DocTip title="Avoid Template $refs" type="warn">

Always try to avoid using the template `$refs` to gain access to the `<Form />` component methods, template `$refs` are designed to be an escape hatch of sorts when all else fails.

So treat them as such and don't reach out for template `$refs` if you can help it.

</DocTip>

# Nested Objects and Arrays

vee-validate supports nested objects and arrays, using field name syntax to indicate a field's path. This allows you to structure forms easily to make data mapping straightforward without having to deal with flat form values.

## Nested Objects

You can specify a field to be nested in an object using dot paths, like what you would normally do in JavaScript to access a nested property. The field `name` prop acts as the path for that field:

```vue
<template>
  <Form @submit="onSubmit">
    <Field name="links.twitter" type="url" />
    <Field name="links.github" type="url" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values) {
  alert(JSON.stringify(values, null, 2));
}
</script>
```

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links": {
    "twitter": "https://twitter.com/logaretm",
    "github": "https://github.com/logaretm"
  }
}
```

You are not limited to a specific depth, you can nest as much as you like.

## Nested Arrays

Similar to objects, you can also nest your values in an array, using square brackets just like how you would do it in JavaScript.

Here is the same example as above but in array format:

```vue
<template>
  <Form @submit="onSubmit">
    <Field name="links[0]" type="url" />
    <Field name="links[1]" type="url" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values) {
  alert(JSON.stringify(values, null, 2));
}
</script>
```

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links": [
    "https://twitter.com/logaretm",
    "https://github.com/logaretm"
  ]
}
```

<DocTip type="warn">

vee-validate will only create nested arrays if the path expression is a complete number, for example, paths like `some.nested[0path]` will not create any arrays because the `0path` key is not a number. However `some.nested[0].path` will create the array with an object as the first item.

</DocTip>

## Avoiding Nesting

If your fields' names are using the dot notation and you want to avoid the nesting behavior which is enabled by default, all you need to do is wrap your field names in square brackets (`[]`) to disable nesting for those fields.

```vue
<template>
  <Form @submit="onSubmit">
    <Field name="[links.twitter]" type="url" />
    <Field name="[links.github]" type="url" />

    <button>Submit</button>
  </Form>
</template>

<script setup>
function onSubmit(values) {
  alert(JSON.stringify(values, null, 2));
}
</script>
```

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links.twitter": "https://twitter.com/logaretm",
  "links.github": "https://github.com/logaretm"
}
```

## Field Arrays <DocBadge title="v4.5" />

Field arrays are a special type of nested array fields, they are often used to collect repeatable pieces of data or repeatable forms. They are often called "repeatable fields".

When dealing with those fields it is better to use `<FieldArray />` component which gives you a few helpers you can use to manage the array fields.

Here is a small example that shows how easy it is to create a repeatable `URL` field:

```vue
<template>
  <Form @submit="onSubmit" :initial-values="initialValues">
    <FieldArray name="links" v-slot="{ fields, push, remove }">
      <div v-for="(entry, idx) in fields" :key="entry.key">
        <Field :name="`links[${idx}]`" type="url" />

        <button type="button" @click="remove(idx)">Remove</button>
      </div>

      <button type="button" @click="push('')">Add</button>
    </FieldArray>

    <button>Submit</button>
  </Form>
</template>

<script setup>
const initialValues = {
  links: ['https://github.com/logaretm'],
};

function onSubmit(values) {
  alert(JSON.stringify(values, null, 2));
}
</script>
```

<DocTip title="Form Context" type="warn">

The `<FieldArray />` component requires being used inside a `Form` component or a `useForm` to be called at its parent tree.

</DocTip>

### Field Array Paths

When planning to use `<FieldArray />` you need to provide a `name` prop which is the path of the array starting from the root form value, you can use dot notation for object paths or indices for array paths.

Here are a few examples:

_*Iterate over the `users` array:*_

```vue-html
<Form>
  <FieldArray name="users" v-slot="{ fields }">
    <div v-for="(entry, idx) in fields" :key="entry.key">
      <Field :name="`users[${idx}].name`" />
    </div>
  </FieldArray>
</Form>
```

_*Iterate over the `domains` inside `settings.dns` object:*_

```vue-html
<Form>
  <FieldArray name="settings.dns.domains" v-slot="{ fields }">
    <div v-for="(entry, idx) in fields" :key="entry.key">
      <Field :name="`settings.dns.domains[${idx}]`" />
    </div>
  </FieldArray>
</Form>
```

_*Iterate over both `users` and `links`:*_

```vue-html
<Form>
  <FieldArray name="users" v-slot="{ fields: users }">
    <div v-for="(userEntry, userIdx) in users">
      <FieldArray :name="`users[${userIdx}].links`" v-slot="{ fields: links }">
        <div v-for="(entry, idx) in fields" :key="entry.key">
          <Field :name="`users[${userIdx}].links[${idx}]`" />
        </div>
      </FieldArray>
    </div>
  </FieldArray>
</Form>
```

### Iteration Keys

The `FieldArrayEntry` item exposes a `key` property, this property is unique and is auto-generated for you so you can use it as an iteration key.

```vue-html
<FieldArray name="users" v-slot="{ fields }">
  <div v-for="(entry, idx) in fields" :key="entry.key">
    <Field :name="`users[${idx}].name`" />
  </div>
</FieldArray>
```

This auto-generated `key` property is very convenient as you no longer have to provide your own unique key for each item.

<DocTip type="warn">

The `key` property is not an index. It is a unique identifier for the array item that is independent of the array index, so you should not be using it to reference field names.

</DocTip>

### Array Helpers

The `<FieldArray />` slot provides the following properties and functions:

- `fields`: a **read-only** version of your array field items, it includes some useful properties like `key`, `isFirst` and `isLast`, the actual item value is inside `.value` property. You should use it to iterate with `v-for`.
- `push(item: any)`: adds an item to the end of the array.
- `insert(idx: number, item: any)`: Inserts an array item at the specified index.
- `prepend(item: any)`: adds an item to the start of the array.
- `remove(idx: number)`: removes the item with the given index from the array.
- `swap(idxA: number, idxB: number)`: Swaps two array elements by their indexes.
- `replace(items: any[])`: Replaces the entire array values with the given items.
- `update(idx: number, value: any)`: Updates an array item value at the specified index.
- `move(oldIdx: number, newIdx: number)`: Moves an array item to a different position within the array.

[Read the API reference](/api/field-array) for more information.

## Caveats

### Paths creation and destruction

vee-validate creates the paths inside the form data automatically but lazily, so initially, your form values won't contain the values of the fields unless you provide initial values for them. It might be worthwhile to provide initial data for your forms with nested paths.

When fields get unmounted like in the case of conditional rendered fields with `v-if` or `v-for`, their path will be destroyed just as it was created if they are the last field in that path. So you need to be careful while accessing the nested field in `values` inside your submission handler or the `Form` component `values` slot prop.

Path destruction can be annoying when dealing with multi-step forms or tabbed forms where you want all the values to be available even when the fields are unmounted. You can control this behavior by passing `keepValue` prop to the `<Field />` component or you can do it for all the fields by passing `keepValues` to the `<Form />` component.

Note that the priority of this configuration follows the field config first then it fallbacks to the form's config.

```vue
<template>
  <!-- All fields values will be kept -->
  <Form keep-values v-slot="{ values }">
    <!-- This field value will be kept -->
    <Field v-if="showFields" name="email" />

    <!-- This field value will be removed -->
    <Field v-if="showFields" name="name" :keep-value="false" />

    <button @click="showFields = !showFields" type="button">Show/Hide fields</button>
    <button>Submit</button>

    <pre>{{ values }}</pre>
  </Form>
</template>

<script>
export default {
  data: () => ({
    showFields: true,
  }),
};
</script>
```

### Referencing Errors

When referencing errors using `errors` object on the `Form` slot props or the `ErrorMessage` component, make sure to reference the field name in the same way you set it on the `name` prop for that field. So even if you avoid nesting you should always include the square brackets. In other words `errors` do not get nested, they are always flat.

### Nested Fields With Validation Schema

Since vee-validate supports [form-level validation](/guide/components/validation#form-level-validation), referencing the nested fields may vary depending on how you are specifying the schema.

If you are using yup, you can utilize the nested `yup.object` or `yup.array` schemas to provide validation for your nested fields, here is a quick example:

```vue
<template>
  <Form v-slot="{ errors }" :validation-schema="schema" @submit="onSubmit">
    <Field name="user.name" />
    <span>{{ errors['user.name'] }}</span>
    <Field name="user.addresses[0]" />
    <span>{{ errors['user.addresses[0]'] }}</span>

    <button>Submit</button>
  </Form>
</template>

<script setup>
import * as yup from 'yup';

const schema = yup.object({
  user: yup.object({
    name: yup.string().required(),
    addresses: yup.array().of(yup.string().required()),
  }),
});

function onSubmit(values: any) {
  fn(values);
}
</script>
```

# Getting started

vee-validate is built from the ground up with the composition API through a collection of functions, mainly the `useField` and `useForm` functions. Internally the `<Form />` and `<Field />` components actually use the composition functions under the hood.

Meaning you can create your own custom input and form components and they will be treated the same as `<Form />` and `<Field />` components. You can mix them together and use a `Form` component with any other custom component that uses `useField` and vice versa.

vee-validate supports synchronous and asynchronous validation and allows defining rules on the field level or the form level using validation schemas. vee-validate has first-class support for:

- [yup](https://github.com/jquense/yup) through `@vee-validate/yup` package.
- [zod](https://github.com/colinhacks/zod) through `@vee-validate/zod` package.
- [valibot](https://github.com/fabian-hiller/valibot) through `@vee-validate/valibot` package.
- [Global validators](/guide/global-validators) (Laravel-like syntax) through `@vee-validate/rules`.

vee-validate has historically been a declarative validation library, and while the composition API changes things a bit, it still follows the same mindset of declarative validation. vee-validate optimizes for building fields and forms, not values.

## When to use composition API

While vee-validate offers both declarative components and composition functions to supercharge your forms, it is always up to you to decide which one to use. However, the composition API is easier to integrate and more flexible. You can build custom components with it or integrate it with any UI library. It is generally recommended to use the composition API.

On this page, you will learn how to declare forms and how to hook your elements and components into vee-validate forms and achieve value tracking, validation, and more.

## Declaring Forms

### Form context

You can declare forms with the `useForm` function exported from the `vee-validate` core package. This is a composition API function that marks the current component as a form.

```vue
<script setup>
import { useForm } from 'vee-validate';

// Creates a form context
// This component now acts as a form
// Usually you will destruct the form context to get what you need
const { values } = useForm();
</script>

<template>
  <pre>{{ values }}</pre>
</template>
```

Calling `useForm` creates a form context in the component and provides it for any child component that injects it. This means you should stick to calling `useForm` once in a component.

Creating a form context does a few things:

- Acts as a value collector for all the fields you will declare as child components.
- Validates the fields and aggregates the errors.
- Aggregates the validity, touched, and dirty states of all the fields.

### Field binds

With `useForm` declared, you are now ready to integrate the form with your elements and components. vee-validate is agnostic to the UI you are using.

You will learn how to associate your components and elements with the form and how to get value collection, validation, and error messages working.

### HTML Inputs

`useForm` provides a function called `defineField`. This function accepts a field path and returns a value model and an object containing the bindings for the input element. The field path is a string that represents the path to the field in the form context.

For example, if you have a field called `email` in the form context, the field path will be `email`.

```ts
const { defineField } = useForm();

const [email, emailAttrs] = defineField('email');
```

Note that `defineField` generates a pair of values, the first one is the value model and the second one is the attributes/props object. The props object contain attributes or event listeners that are useful to have on the input control or component which enables custom validation triggers and more.

Here is a basic example of how to use `defineField` with a simple input element:

<Repl files={{ 'App.vue': 'CompositionInputBindsBasic01' }} client:visible />

Notice that as you type in the input, the `values` are automatically updated with the value changes.

Let's quickly add a validation schema on the form to see some errors on the form. We will be using `yup` throughout the examples, but you can use `zod` or any other supported validation library you want.

To add a `yup` schema or any kind of form schema, you pass it to the `validationSchema` option when calling `useForm`. Naturally, form schemas are almost always an `object` or a `shape` schema.

```ts{1,3-5,8}
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required().email(),
});

const { defineField } = useForm({
  validationSchema: schema,
});

const [email, emailAttrs] = defineField('email');
```

Here is a full running example:

<Repl files={{ 'App.vue': 'CompositionInputBindsBasic02' }} client:visible />

Notice as you type into the input, the validation is then triggered and the errors are populated. By default `defineField` optimizes for aggressive validation, meaning the validation will be triggered whenever the model changes.

You can change that behavior. For example, you can make it "lazy" by passing a configuration to `defineField` to disable validation on model updates with `validateOnModelUpdate` config.

<Repl files={{ 'App.vue': 'CompositionInputBindsBasic03' }} client:visible />

Now as you type in the field, the input is not immediately validated. You can do more with dynamic configurations.

### Components

Similarly to HTML inputs, you can achieve the same results with the same `defineField` function.

Following the previous examples we can achieve value tracking like this:

<Repl files={{ 'App.vue': 'CompositionComponentBindsBasic01', 'CustomInput.vue': 'CustomInputBasic' }} client:visible />

As you type into the input, notice that the `values` are being updated.

Let's add validation to the previous example:

<Repl files={{ 'App.vue': 'CompositionComponentBindsBasic02', 'CustomInput.vue': 'CustomInputBasic' }} client:visible />

Notice that for components, validations are executed immediately. This is intended because component implementations are not standardized across the Vue ecosystem as there is no guarantee it will emit the same range of events as the native HTML elements. However, you can customize the validation trigger if you know the components you are using are emitting the right events to support the behavior.

<Repl files={{ 'App.vue': 'CompositionComponentBindsBasic03', 'CustomInput.vue': 'CustomInputBasic' }} client:visible />

### Mapping attributes and props

But aside from the attributes and listeners that vee-validate adds to those binding objects, you can also map the attributes and props of the in. This is useful when you want to:

- Map the attributes/props to a different name.
- Pass new attributes/props to the component/element based on the field state.

You can use `props` to include any additional props or attributes you need to add to the component/element.

```ts
const { defineField } = useForm({
  // ...
});

const [email, emailProps] = defineField('email', { props: state => ({ error: state.errors[0] }) });
```

In the following example, we have a component that accepts an `error` string prop and shows that message if it is not empty. This is common in many UI libraries as they try not to lock you into a specific validation library.

<Repl
  files={{ 'App.vue': 'CompositionComponentBindsBasic04', 'CustomInput.vue': 'CustomInputBasicError' }}
  client:only
/>

<DocTip>

The `state` object contains a lot of useful information about the field, it is fully typed so you can explore it with your IDE or visit the [source reference](https://github.com/logaretm/vee-validate/blob/main/packages/vee-validate/src/types/forms.ts#L255-L258) for more information.

</DocTip>

Notice that `form` also gives you access to `errors` so you can reference them anywhere in the component.

### Dynamic configuration

Instead of passing a static configuration object `defineField`, you could pass a function that returns different configuration values. This is useful when you want the configuration to be dynamic based on the field state.

Here is an example that shows how to make the validation behavior "eager". Meaning if the field does not have any errors then it will only validate on `change`.

But once it is invalid, it validates on each input event, making it "eager" for success.

<Repl files={{ 'App.vue': 'CompositionComponentBindsBasic05' }} client:visible />

## Form Schema

As you have seen in the previous examples, the `useForm` function accepts a `validationSchema` that is used to validate the form. We've been using yup to define the schema however you can use `zod` or any 3rd-party validators.

### Validating with Yup

You can pass yup schemas directly as you've seen previously, but it is recommended that you use the `@vee-validate/yup` package. It will enable better support of yup features and unlock full typescript support for your schemas.

```sh
# with npm
npm i @vee-validate/yup
# with pnpm
pnpm add @vee-validate/yup
# with yarn
yarn add @vee-validate/yup
```

The package exposes a `toTypedSchema` function that you can use to wrap your yup schemas, this allows vee-validate to infer form input and output types. [More on that here](/guide/composition-api/typed-schema).

```ts
import { useForm } from 'vee-validate';
import { toTypedSchema } from '@vee-validate/yup';
import * as yup from 'yup';

// Creates a typed schema for vee-validate
const schema = toTypedSchema(
  yup.object({
    email: yup.string().required().email(),
  }),
);

const { errors, values } = useForm({
  validationSchema: schema,
});
```

<Repl files={{ 'App.vue': 'CompositionYupBasic' }} client:visible />

<DocTip title="Yup Schema Optimizations" type="warn">

There are a couple of optimization caveats when it comes to using `yup` schemas to validate your forms, be sure to check the [best practices guide](/guide/best-practices).

</DocTip>

### Validating with Zod

You can use [Zod](https://github.com/colinhacks/zod) in a very similar manner to how we've been using yup in the past examples. However, you will need to add `@vee-validate/zod` to your dependencies.

```sh
# with npm
npm i @vee-validate/zod
# with pnpm
pnpm add @vee-validate/zod
# with yarn
yarn add @vee-validate/zod
```

Then you can wrap your zod schemas with `toTypedSchema` function which allows vee-validate to infer form input and output types. [More on that here](/guide/composition-api/typed-schema).

```ts
import { useForm } from 'vee-validate';
import { toTypedSchema } from '@vee-validate/zod';
import { z } from 'zod';

// Creates a typed schema for vee-validate
const schema = toTypedSchema(
  z.object({
    email: z.string().nonempty().email(),
  }),
);

const { errors, values } = useForm({
  validationSchema: schema,
});
```

Here is a full example using zod with `useForm`:

<Repl files={{ 'App.vue': 'CompositionZodBasic' }} client:visible />

<DocTip title="refine/superRefine">

There is a known issue with Zod's `refine` and `superRefine` not executing whenever some object keys are missing which is common with forms. This is not an issue with vee-validate as it is a design choice in Zod at the moment. Refer to [this issue](https://github.com/logaretm/vee-validate/issues/4338) for explanations and further reading.

</DocTip>

### Validating with Valibot

You can also use [Valibot](https://valibot.dev/) which is is a schema library with bundle size, type safety and developer experience in mind. It is a great alternative to Yup and Zod if bundle size is a concern. You will need to use the `@vee-validate/valibot` package to use valibot schemas.

```sh
# with npm
npm i @vee-validate/valibot
# with pnpm
pnpm add @vee-validate/valibot
# with yarn
yarn add @vee-validate/valibot
```

Then you can wrap your Valibot schemas with `toTypedSchema` function which allows vee-validate to infer form input and output types. [More on that here](/guide/composition-api/typed-schema).

```ts
import { useForm } from 'vee-validate';
import * as v from 'valibot';
import { toTypedSchema } from '@vee-validate/valibot';

// Creates a typed schema for vee-validate
const schema = toTypedSchema(
  v.object({
    email: v.pipe(v.string(), v.email('Invalid email'), v.nonEmpty('required')),
  }),
);

const { errors, values } = useForm({
  validationSchema: schema,
});
```

Here is a full example using valibot with `useForm`:

<Repl files={{ 'App.vue': 'CompositionValibotBasic' }} client:visible />

### Other validation providers and options

#### Global Rules

Another option is using `@vee-validate/rules` which have been historically bundled with past versions of vee-validate. It includes rules that can be defined globally and then used anywhere using Laravel-like string expressions.

You can refer to the full guide on global rules [here](/guide/global-validators).

#### Validating with functions

Another option is to just use any 3rd party validation tool you prefer, something like [`validator.js`](https://github.com/validatorjs/validator.js/). Here is a quick example:

<Repl files={{ 'App.vue': 'CompositionValidateFnBasic' }} client:visible />

Or you could use any custom function.

<DocTip>

Both `zod` and `yup` are very good at defining schemas especially nested values so it is recommended that you use either. As an added bonus, you get full typescript support with either of them. You can refer to the [Typed schemas guide](/guide/composition-api/typed-schema) to learn more about how to maximize the type safety of your schemas.

</DocTip>

### Dynamic Form Schemas

There are a few ways you can create dynamic schemas (reactive) where it changes the validation rules based on some state. The first way to do that is with `computed`.

<Repl files={{ 'App.vue': 'CompositionDynamicSchemaComputed' }} client:visible />

When the validation schema value changes, only the fields that were validated at least once will be re-validated, the other fields won't be validated to avoid aggressive validation behavior.

There are other ways depending on which validation library you are using. For example, with `yup` you can achieve the same with `yup.lazy` or `zod.lazy`

# Handling Forms

vee-validate makes it easy to handle form submissions, resets, and DX to make your forms much easier to reason about and less of a burden to maintain. The `useForm` function allows you to easily handle:

<div class="features">

- Form state (valid/dirty/touched/pending).
- Submitting forms and handling invalid submissions.
- Handling form resets.

</div>

## Form Metadata

Forms have a `meta` object value containing useful information about the form, it acts as an aggregation of the metadata for the fields inside that form.

```js
const { meta } = useForm();

meta.value.dirty;
meta.value.pending;
meta.value.touched;
meta.value.valid;
meta.value.initialValues;
```

- `valid`: The form's validity status, will be `true` if the errors array is empty initially, but will be updated once the form is mounted.
- `touched`: If at least one field was blurred (unfocused) inside the form.
- `dirty`: If at least one field's value was updated.
- `pending`: If at least one field's validation is still pending.
- `initialValues`: All fields' initial values, this is an object where the keys are the field names.

Here is a simple example where we disable the form's submit button unless a field was touched.

<Repl files={{ 'App.vue': 'CompositionHandlingForms01' }} client:visible />

## Handling Submissions

vee-validate exposes useful defaults to help you handle form submissions whether you submit them using JavaScript or native HTML submissions.

### JavaScript Submissions (AJAX)

To handle submissions, you can use the `handleSubmit` function to create submission handlers for your forms, the `handleSubmit` function accepts a callback that receives the final form values.

```js
const { handleSubmit } = useForm({
  validationSchema: yup.object({
    email: yup.string().email().required(),
    password: yup.string().min(6).required(),
  }),
});

// Creates a submission handler
// It validates all fields and doesn't call your function unless all fields are valid
// You can bind `onSubmit` to a form element's submit event, or call it directly to submit the current data.
const onSubmit = handleSubmit(values => {
  alert(JSON.stringify(values, null, 2));
});
```

Here is an example that makes use of `handleSubmit` to validate before submitting the form.

<Repl files={{ 'App.vue': 'CompositionHandlingForms02' }} client:visible />

The `handleSubmit` function will only execute your callback once the returned function (`onSubmit` in the example) if all fields are valid, meaning you don't have to handle if the form is invalid in your logic.

You can call the returned function either manually or via an event like `@submit` and it will validate all the fields and execute the callback if everything passes validation.

As a bonus, when the returned function is used as an event handler (like in the previous example) it will automatically prevent the default submission of the form so you don't need to use the `prevent` modifier like you normally would.

### Full-Page Submissions (non-AJAX)

For non-ajax submissions that trigger a full page reload, you can use the `submitForm` function instead of `handleSubmit`. You normally would use this if you are not building a single-page application. In the following example, we submit the form to another tab using the `get` form method.

<Repl files={{ 'App.vue': 'CompositionHandlingForms13' }} client:visible />

In that case **YOU MUST** use `submitForm` as an event handler for the `submit` event for a native `form` element, otherwise, it would have no effect.

### Handling Invalid Submissions

Sometimes you want to perform some logic after a form fails to submit due to validation errors (e.g. focusing the first invalid field), you can pass a callback as the second argument to the `handleSubmit` function.

```js
const { handleSubmit } = useForm();

function onSuccess(values) {
  alert(JSON.stringify(values, null, 2));
}

function onInvalidSubmit({ values, errors, results }) {
  console.log(values); // current form values
  console.log(errors); // a map of field names and their first error message
  console.log(results); // a detailed map of field names and their validation results
}

// This handles both valid and invalid submissions
const onSubmit = handleSubmit(onSuccess, onInvalidSubmit);
```

Here is a quick example of how to scroll to and focus the first invalid field after a failed submission attempt.

<Repl files={{ 'App.vue': 'CompositionHandlingForms03' }} client:visible />

### Submission Progress

Quite often you need to show your users a submission indicator, or you might want to disable the submit button entirely until the submission attempt is done. The `useForm` function exposes an `isSubmitting` ref that you can use.

The `isSubmitting` state will be set to `true` once the validation of the form starts (as a result of a submit event) and will keep track of the submission handler you passed to either `onSubmit` or until it calls `submitForm`. If the submission handler throws any errors or completes successfully it will be set to `false` afterward.

```js
const { isSubmitting } = useForm();
```

<Repl files={{ 'App.vue': 'CompositionHandlingForms04' }} client:visible />

### Submit Count

The `useForm` function also exposes a `submitCount` ref that you can use to track the number of submissions attempted by the user. The count is incremented regardless of the validation result.

```js
const { submitCount } = useForm();
```

Maybe you want to lock the form if too many attempts were made, or you want to show a message after the first submission attempt.

<Repl files={{ 'App.vue': 'CompositionHandlingForms05' }} client:visible />

### Submission Behavior

vee-validate does the following when calling submission handlers created by `handleSubmit` or when calling `submitForm` as a result of the user submitting the form.

#### Before validation stage

- Sets all fields `touched` meta to `true`
- Sets `isSubmitting` form state to `true`
- Increments the `submitCount` form state by `1`

#### Validation stage

- Sets form and individual fields meta `pending` to `true` to indicate validation is in progress
- Runs the validation function/schema/rule against the current form values asynchronously
- Checks for any errors in the validation result
  - If there are errors then it will skip the next stage and update the validation state (meta, errors) for the form and fields
  - If there aren't any errors then it will set the `pending` meta flag to `false` and proceed to the next stage

#### After validation stage

- Calls the `handleSubmit` handler you passed
- After the callback finishes (it will wait if the result is asynchronous), then it will set `isSubmitting` to `false`

Note that there isn't a need to have `isSubmitting` set back to false if you've used `submitForm`, as this submission method will perform a full-page refresh (native forms behavior).

## Form Values

You may have noticed in the earlier examples that you can access all fields' values using the `values` reactive object returned by `useForm`.

```js
const { values } = useForm();
```

The `values` object is read-only and should not be mutated with a `v-model` or by assigning a value to it. This is because all mutations are done through the vee-validate API, this is because mutations to form state need to have a context.

For example:

```js
const { values } = useForm();

// ❌ Do not do that!
values.email = '';
```

In order for the form UX to be stable, we need to understand why the email value was set to `''`. Was it being reset? Should we run validation again? This is the type of small differences that are a result of vee-validate's design choice based on fields and forms, not values.

### Initial Values

Since you don't have to use `v-model` to track your values, the `useForm` function allows you to define the starting values for your fields, by default all fields start with `undefined` as a value.

Using the `initialValues` option you can send an object that contains the field names as keys and their values:

```js
const { defineInputBinds } = useForm({
  initialValues: {
    email: 'test@example.com',
    password: 'p@$$w0rd',
  },
});
```

<Repl files={{ 'App.vue': 'CompositionHandlingForms06' }} client:visible />

<DocTip>

It's generally recommended that you provide the `initialValues`, this is because vee-validate cannot assume a reasonable initial value for your fields other than `undefined` which may cause unexpected behavior when using a 3rd-party validator that does not deal with `undefined`.

</DocTip>

<DocTip>

If you are using `zod` or `yup` with [Typed schemas](/guide/composition-api/typed-schema), you can define the initial values on the validation schema directly with `.default` instead of having to specify `initialValues`.

</DocTip>

You can reset initial values at [any time using the `resetForm`](#handling-resets) function returned by `useForm`.

### Manually Setting Form Values

You can set any field's value using either `setFieldValue` or `setValues` returned by `useForm`.

```js
const { setFieldValue, setValues } = useForm();

// Sets a value of a specific field in the form values
setFieldValue('fieldName', 'value');

// Merges the given object with the current form values
setValues({
  fieldName: 'value',
});
```

<Repl files={{ 'App.vue': 'CompositionHandlingForms07' }} client:visible />

### Controlled Values

The form values can be categorized into two categories:

- Controlled values: values that have a form input controlling them via `defineInputBinds` or `defineComponentBinds` or `useField` or `<Field />`.
- Uncontrolled values: values that are inserted dynamically with `setFieldValue` or inserted initially with initial values.

Sometimes you maybe only interested in controlled values. For example, your initial data contains noisy extra properties from your API and you wish to ignore them when submitting them back to your API.

When accessing `values` from `useForm` result or the submission handler you get all the values, both controlled and uncontrolled values. To get access to only the controlled values you can use `controlledValues` from the `useForm` result:

```js
const { handleSubmit, controlledValues } = useForm();

const onSubmit = handleSubmit(async () => {
  // Send only controlled values to the API
  const response = await client.post('/users/', controlledValues.value);
});
```

Alternatively, for less verbosity, you can create submission handlers with only the controlled values with `handleSubmit.withControlled` which has the same API as `handleSubmit`:

```js
const { handleSubmit } = useForm();

const onSubmit = handleSubmit.withControlled(async values => {
  // Send only controlled values to the API
  const response = await client.post('/users/', values);
});
```

Here is an example that filters out some noisy initial values when submitting the form using the `withControlled` modifier.

<Repl files={{ 'App.vue': 'CompositionHandlingForms12' }} client:visible />

### Setting initial values asynchronously

Sometimes your data is fetched asynchronously from an API and you want to set the initial values or the current values after the data is fetched. You can do that by using `resetForm` to set both current and initial data.

<Repl files={{ 'App.vue': 'CompositionHandlingForms14' }} client:visible />

You could alternatively use `setValues` but note that `setValues` can trigger validation and do not reset the meta state for the fields like `dirty` or `touched`.

## Handling Resets

vee-validate also handles form resets in a similar way to submissions. When resetting the form, all fields' errors will be cleared, meta info will be reset to defaults and the values will be reset to their original or initial values.

To reset forms you can use the `resetForm` function returned by `useForm`. You can also reset the form to a new state by passing a `FormState` object to the `resetForm` function. You can then set errors, `touched` meta, and the values.

```js
const { resetForm } = useForm();

// Rests the form
resetForm();

//
resetForm({
  touched: {
    email: false,
  },
  errors: {
    email: 'custom error',
  },
  values: {
    email: 'newvalue@email.com',
  },
});
```

This is the shape of the `FormState` object:

```ts
interface FormState {
  // any error messages
  errors: Record<string, string>;
  // touched meta flags
  touched: Record<string, boolean>;
  // Form Values
  values: Record<string, any>;
}
```

Here is an example where a full form is being reset:

<Repl files={{ 'App.vue': 'CompositionHandlingForms08' }} client:visible />

### Resetting Forms After Submit

Usually, you will reset your forms after successful submission. For convenience, the `onSubmit` handler receives an additional `FormActions` object in the second argument that allows you to do some actions on the form after submissions, this is the shape of the `FormActions` object:

```ts
export interface FormActions {
  setFieldValue: (field: T, value: any) => void;
  setFieldError: (field: string, message: string | undefined) => void;
  setErrors: (fields: Partial<Record<string, string | undefined>>) => void;
  setValues: (fields: Partial<Record<T, any>>) => void;
  setFieldTouched: (field: string, isTouched: boolean) => void;
  setTouched: (fields: Partial<Record<string, boolean>>) => void;
  resetForm: (state?: Partial<FormState>) => void;
}
```

This is an example of using the form actions object to reset the form:

<Repl files={{ 'App.vue': 'CompositionHandlingForms09' }} client:visible />

## Errors

As you have previously seen in some examples, you have access to `errors` with `useForm` that contains a mapping of each field's path and its error message.

```js
const { errors } = useForm();
```

However, if you want to display multiple errors for your fields then you can use `errorBag` which is a mapping of each field's path and an array of error messages for that field.

```js
const { errorBag } = useForm();
```

Here is an example that displays multiple errors for a field:

<Repl files={{ 'App.vue': 'CompositionHandlingForms10' }} client:visible />

### Initial Errors

If you are building a non-SPA application it is very common to pre-fill form errors using server-side rendering, frameworks like Laravel and Rails make this very easy to do. vee-validate supports filling the errors initially before any validation is done using the `initialErrors` option.

The `initialErrors` option accepts an object containing the field names as keys with their corresponding error message string.

```js
useForm({
  initialErrors: {
    email: 'This email is already taken',
    password: 'The password is too short',
  },
});
```

<DocTip>

`initialErrors` are applied once the component that called `useForm` is mounted and is ignored after, so any changes to the `initialErrors` props won't affect the messages.

</DocTip>

### Setting Errors Manually

Quite often you will find yourself unable to replicate some validation rules on the client-side due to natural limitations. For example, `unique` email validation is complex to implement on the client side. So the ability to set errors manually can be useful.

You can set messages for fields by using either `setFieldError` which sets an error message for one field at a time, or by using the `setErrors` function which allows you to set error messages for multiple fields at once.

Both functions are available as a return value from `useForm`. In the following example, we check if the server response contains any validation errors and we set them on the fields:

```js
const { handleSubmit, setFieldError, setErrors } = useForm();

const onSubmit = handleSubmit(async values => {
  // Send data to the API
  const response = await client.post('/users/', values);

  // all good
  if (!response.errors) {
    return;
  }

  // set single field error
  if (response.errors.email) {
    setFieldError('email', response.errors.email);
  }

  // set multiple errors, assuming the keys are the names of the fields
  // and the key's value is the error message
  setErrors(response.errors);
});
```

Alternatively, you can use the `FormActions` passed as the second argument to the `handleSubmit` callback which contains both functions for convenience:

```js
const onSubmit = handleSubmit(async (values, actions) => {
  // Send data to the API
  const response = await client.post('/users/', values);
  // ...

  // set single field error
  if (response.errors.email) {
    actions.setFieldError('email', response.errors.email);
  }

  // set multiple errors, assuming the keys are the names of the fields
  // and the values is the error message
  actions.setErrors(response.errors);
});
```

# Nested Objects and Arrays

vee-validate supports nested objects and arrays by using field path syntax to indicate a field's path. This allows you to structure forms easily to make data mapping straightforward without having to deal with flat form values.

## Nested Objects

You can specify a field to be nested in an object using dot paths, like what you would normally do in JavaScript to access a nested property. The field's `name` acts as the path for that field in the form values:

```js
const { defineInputBinds } = useForm();

const twitterLink = defineInputBinds('links.twitter');
const githubLink = defineInputBinds('links.github');
```

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links": {
    "twitter": "https://twitter.com/logaretm",
    "github": "https://github.com/logaretm"
  }
}
```

Here is a live example so you can see it in action.

<Repl files={{ 'App.vue': 'CompositionNested01' }} client:visible />

You are not limited to a specific depth, you can nest as much as you like.

## Nested Arrays

Similar to objects, you can also nest your values in an array, using square brackets just like how you would do it in JavaScript.

```js
const { defineInputBinds } = useForm();

const twitterLink = defineInputBinds('links[0]');
const githubLink = defineInputBinds('links[1]');
```

Here is the same example as above but in array format:

<Repl files={{ 'App.vue': 'CompositionNested02' }} client:visible />

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links": [
    "https://twitter.com/logaretm",
    "https://github.com/logaretm"
  ]
}
```

<DocTip type="warn">

vee-validate will only create nested arrays if the path expression is a complete number, for example, paths like `some.nested[0path]` will not create any arrays because the `0path` key is not a number. However `some.nested[0].path` will create the array with an object as the first item.

</DocTip>

## Avoiding Nesting

If your fields' names are using the dot notation and you want to avoid the nesting behavior which is enabled by default, all you need to do is wrap your field names in square brackets (`[]`) to disable nesting for those fields.

```js
const { defineInputBinds } = useForm();

const twitter = defineInputBinds('[links.twitter]');
const github = defineInputBinds('[links.github]');
```

Submitting the previous form would result in the following values being passed to your handler:

```js
{
  "links.twitter": "https://twitter.com/logaretm",
  "links.github": "https://github.com/logaretm"
}
```

Here is a live example on that:

<Repl files={{ 'App.vue': 'CompositionNested03' }} client:visible />

## Field Arrays

Field arrays are a special type of nested array fields, they are often used to collect repeatable pieces of data or repeatable forms. They are often called "repeatable fields".

To set up a repeatable block of the form, you can use `useFieldArray` to help you manage the array values and operations. It requires a form context to be present so `useForm` must be called before you use `useFieldArray` either in parent component or in the same component.

```js
import { useForm, useFieldArray } from 'vee-validate';

useForm();

const { remove, push, fields } = useFieldArray('users');
```

The `useFieldArray` exposes a few properties and functions to help you manage the array fields, the most special one is the `fields` array which contains the array items and represents their current value in the form. You will use `fields` as an iteration source to render the array items.

Here is an example of a repeatable block of fields, we mutate the field value with `v-model` directly on the iteration item value.

<Repl files={{ 'App.vue': 'CompositionNested04' }} client:visible />

Notice that we used `field.key` as the key of the iteration, this is because vee-validate generates a unique key for each array item so you can rely it on without having to generate them yourself.

<DocTip type="warn">

The `key` property generated on array items is not an index. It is a unique identifier for the array item that is independent of the array index, so you should not be using it to reference field names.

</DocTip>

### Field Array Paths

When calling `useFieldArray` you need to provide a `name` prop which is the path of the array starting from the root form value, you can use dot notation for object paths or indices for array paths.

Here are a few examples:

_*Iterate over the `users` array:*_

```js
const { remove, push, fields } = useFieldArray('users');
```

_*Iterate over the `domains` inside `settings.dns` object:*_

```js
const { remove, push, fields } = useFieldArray('settings.dns.domains');
```

### Array Helpers

The `<useFieldArray />` function provides the following properties and functions:

- `fields`: a **read-only** version of your array field items, it includes some useful properties like `key`, `isFirst` and `isLast`, the actual item value is inside `.value` property. You should use it to iterate with `v-for`.
- `push(item: any)`: adds an item to the end of the array.
- `prepend(item: any)`: adds an item to the start of the array.
- `insert(idx: number, item: any)`: Inserts an array item at the specified index.
- `remove(idx: number)`: removes the item with the given index from the array.
- `swap(idxA: number, idxB: number)`: Swaps two array elements by their indexes.
- `replace(items: any[])`: Replaces the entire array values with the given items.
- `update(idx: number, value: any)`: Updates an array item value at the specified index.
- `move(oldIdx: number, newIdx: number)`: Moves an array item to a different position within the array.

[Read the API reference](/api/use-field-array) for more information.

## Caveats

### Paths creation and destruction

vee-validate creates the paths inside the form data automatically but lazily, so initially, your form values won't contain the values of the fields unless you provide initial values for them. It might be worthwhile to provide initial data for your forms with nested paths.

When fields get unmounted like in the case of conditional rendered fields with `v-if` or `v-for`, their path will be destroyed just as it was created if they are the last field in that path. So you need to be careful while accessing the nested field in `values` inside your submission handler.

Path destruction can be annoying when dealing with multi-step forms or tabbed forms where you want all the values to be available even when the fields are unmounted. You can control this behavior by passing `keepValueOnUnmount` prop to the `useField` function or you can do it for all the fields by passing `keepValuesOnUnmount` to the `useForm` function.

Note that the priority of this configuration follows the field config first then it fallbacks to the form's config.

```js
import { useForm } from 'vee-validate';

// keep all values when their fields get unmounted
const { values } = useForm({
  keepValuesOnUnmount: true,
});
```

```js
import { useField } from 'vee-validate';

// this field value will be removed
const field = useField('field', undefined, {
  keepValueOnUnmount: false,
});
```

### Referencing Errors

When referencing errors using `errors` object returned from the `useForm` function. Make sure to reference the field name in the same way you set it on the `name` argument for that field. So even if you avoid nesting you should always include the square brackets. In other words `errors` do not get nested, they are always flat.

Since vee-validate supports `yup` and `zod` schemas, referencing the nested fields may vary depending on how you are specifying the schema.

If you are using yup, you can utilize the nested `yup.object` or `yup.array` schemas to provide validation for your nested fields

# Building Custom inputs

import DocTip from '@/components/DocTip.vue';
import Repl from '@/components/MdxRepl.vue';

## Imperative vs Declarative

So far we've been using `useForm` to create forms and use `defineField` to create field-binding objects to integrate them with our fields. However, that usually requires a lot of boilerplate code to create the binding object and the field component.

For example, this is how a 5-field form looks like with `useForm` and `defineField`:

```js
const { defineField } = useForm();

const email = defineField('email');
const firstName = defineField('firstName');
const lastName = defineField('lastName');
const password = defineField('password');
const passwordConfirm = defineField('passwordConfirm');
```

This can get ugly very quickly especially if you have a lot of field arrays or nested fields involved. This is one of the downsides of using an imperative API, but with `useField` you can switch to declarative API and get rid of all that boilerplate code.

`useField` is a composition function that is similar to `useForm`. it makes it easier to create and manage input components. You should use it when creating custom input components and that means you've made the choice that vee-validate will be an integral part of your input component system.

## Creating a custom input component

Let's start with a simple example, we will create a `InputText` component that represents a text field. It can be as simple as this:

```vue
<template>
  <input v-model="value" />
  {{ errorMessage }}
</template>

<script setup>
import { useField } from 'vee-validate';

const props = defineProps({
  name: String,
});

// The `name` is returned in a function because we want to make sure it stays reactive
// If the name changes you want `useField` to be able to pick it up
const { value, errorMessage } = useField(() => props.name);
</script>
```

This works exactly the same way as with `defineField`, but now since you have a vee-validate field component, you can use it directly in any component with a form context and it will just work:

Here is a live example:

<Repl files={{ 'App.vue': 'CompositionCustomField01', 'InputText.vue': 'CustomInputFieldBasic' }} client:visible />

Notice how much of the burden of defining fields went away as soon as switched to the declarative approach. This is where `useField` really shines, but that's just us getting started. Follow along in this guide to make the most out of `useField`.

## Validation

All previous examples have used the form's validation schema to validate the individual fields, however, you can also define a validation schema for each field individually. The same types of validation libraries are supported.

<DocTip title="Yup Typed Schema">

You can only validate using field-level validation or form-level validation, you cannot mix the two approaches here.

</DocTip>

### Validating with yup

You can use Yup schemas to validate fields individually by passing the schema as the second argument to `useField`.

<Repl files={{ 'App.vue': 'CompositionInputFieldYup' }} client:visible />

### Validating with Zod

You can use [Zod](https://github.com/colinhacks/zod), however, you will need to add `@vee-validate/zod` to your dependencies.

```sh
# with npm
npm i @vee-validate/zod
# with pnpm
pnpm add @vee-validate/zod
# with yarn
yarn add @vee-validate/zod
```

Then you can wrap your zod field schemas with `toTypedSchema` function. [More on that here](/guide/composition-api/typed-schema).

<Repl files={{ 'App.vue': 'CompositionInputFieldZod' }} client:visible />

### Validating with Valibot

You can use [Valibot](https://valibot.dev/) to validate your fields, however, you will need to add `@vee-validate/valibot` to your dependencies.

```sh
# with npm
npm i @vee-validate/valibot
# with pnpm
pnpm add @vee-validate/valibot
# with yarn
yarn add @vee-validate/valibot
```

Then you can wrap your valibot field schemas with `toTypedSchema` function. [More on that here](/guide/composition-api/typed-schema).

<Repl files={{ 'App.vue': 'CompositionInputFieldValibot' }} client:visible />

### Other validation providers

#### Validating with global validators

Another option is using `@vee-validate/rules` which have been historically bundled with past versions of vee-validate. It includes rules that can be defined globally and then used anywhere using Laravel-like string expressions.

You can refer to the full guide on global rules [here](/guide/global-validators).

#### Validating with functions

Another option is to just use any 3rd party validation tool you prefer.

<Repl files={{ 'App.vue': 'CompositionInputFieldFn' }} client:visible />

### Triggers

#### Default Behavior

By default, vee-validate runs validation whenever the `value` ref changes whether it was bound by a `v-model` or changed in your code:

```js
const { value } = useField('fieldName', yup.string().required());

// validation WILL be triggered
value.value = 'something';
```

You can disable that behavior by passing a `validateOnValueUpdate` option set to `false`:

```js
const { value } = useField('fieldName', yup.string().required(), {
  validateOnValueUpdate: false,
});

// validation WILL NOT trigger
value.value = 'something';
```

#### Handling Events

`useField()` composition function is not concerned with any events, it only validates whenever the `value` ref changes. However, it gives you everything you need to set up your own validation experience.

The `useField` function exposes some handler functions, each handling a specific aspect of the validation experience:

- `handleChange`: Updates the field value, can be configured to trigger validation or silently update the value
- `handleBlur`: Updates the `meta.touched` flag, doesn't trigger validation.

```js
const { handleChange, handleBlur } = useField('someField');
```

In this example, we are validating on the `input` event (when the user types), which would make the validation aggressive:

<Repl files={{ 'App.vue': 'CompositionCustomField03', 'InputText.vue': 'CustomInputFieldAggressive' }} client:visible />

With a slight adjustment we can make our validation lazy by changing the listener to `@change` (validates when the user leaves the control):

```vue-html
<div>
  <input @change="handleChange" :value="value" type="text" />
  <span>{{ errorMessage }}</span>
</div>
```

Note that `handleChange` can be called anywhere, not just in the template, and not as just an event handler. You can use it to mutate the field value whenever you want, as an added bonus you can choose if `handleChange` should trigger a validation or not.

```js
const { handleChange } = useField('someField');

// validates by default
handleChange('new value');
// validates
handleChange('new value', true);
// Doesn't validate
handleChange('new value', false);
```

Let's say you want to validate on `blur` instead. You can use the `handleBlur` in a similar way. The main differences are:

- `handleBlur` doesn't mutate the `value` of the field. It only sets the `meta.touched` to `true`.
- `handleBlur` does not validate the current value by default, you have to pass `true` as a second argument to trigger validation.

With that info in mind, you can validate on `blur` like so:

```vue-html
<div>
  <input
    :value="value"
    type="text"
    @change="handleChange"
    @blur="handleBlur($event, true)"
  />
  <span>{{ errorMessage }}</span>
</div>
```

As you can see, the `useField` doesn't care which events you use `handleChange` for. This allows for greater flexibility that's not possible with the `<Field>` component, not as straightforward at least.

Consider this validation experience:

- Validate on Change/Blur initially (when the user leaves the control), let's call this lazy mode.
- If the field is invalid, switch the validation to validate on input (when the user types), let's call this aggressive mode.
- If the field is valid, go back to "lazy" mode, otherwise, be "aggressive".

Implementing this requires some knowledge about how the `v-on` (we can bind objects on it) handler works.

```js
const { errorMessage, value, handleChange } = useField(() => props.name, undefined, {
  validateOnValueUpdate: false,
});

const validationListeners = {
  blur: evt => handleBlur(evt, true),
  change: handleChange,
  input: evt => handleChange(evt, !!errorMessage.value),
};
```

Then in your template, you can use `v-on` to add your listener object:

```vue-html
<input :value="value" v-on="validationListeners" type="text" />
```

Here is a full example:

<Repl files={{ 'App.vue': 'CompositionCustomField03', 'InputText.vue': 'CustomInputFieldEager' }} client:visible />

## v-model Support

The `useField` function can automatically manage `v-model` integration for you. Usually, you will need to do this in every component you create:

```js
const props = defineProps({
  modelValue: String,
});

const emit = defineEmits(['update:modelValue']);
```

Instead, you can let `useField` do that for you by telling it to enable `v-model` syncing:

```js
const props = defineProps({
  modelValue: String,
});

const { value, errorMessage } = useField('fieldName', undefined, {
  syncVModel: true,
});
```

Now whenever `value` changes, you will emit an `update:modelValue` event with the new value. This is useful when you want to use `v-model` with your custom input component:

<Repl files={{ 'App.vue': 'CompositionCustomField02', 'InputText.vue': 'CustomInputFieldVModel' }} client:visible />

You can also use different prop names for the `modelValue`, for example, `v-model:text` can be implemented by passing the model name directly to `syncVModel`.

```js
const props = defineProps({
  text: String,
});

const { value, errorMessage } = useField('fieldName', undefined, {
  syncVModel: 'text',
});
```

This will emit `onUpdate:text` instead of `onUpdate:modelValue` whenever the `value` changes.

## Displaying Error Messages

You've already seen how to display errors with `useForm`. With `useField` you can use `errorMessage` ref:

```js
const { errorMessage, value } = useField('fieldName', yup.string().required());

// contains the error message if available
errorMessage.value;
```

In addition to this, you can get all errors for the field using the `errors` ref which contains multiple error messages if applicable:

```js
const { errors, value } = useField('fieldName', yup.string().required());

// contains an array of error messages, otherwise empty array
errors.value;
```

Here is an example where each field displays its entire range of error messages:

<Repl
  files={{ 'App.vue': 'CompositionCustomField04', 'InputText.vue': 'CustomInputFieldMultiErrors' }}
  client:visible
/>

### Custom Field Labels

More often than not, your fields will have names with underscores or shorthands which isn't very nice when showing in error messages, for example, you might have specific encoding to your field names because they might be generated by the backend. Ideally, you want to avoid having messages like:

```txt
The down_p is required
```

And instead show something more meaningful to the user

```txt
The down payment is required
```

You can do this in two ways depending on which validators you are using (yup or [global validators](/guide/global-validators)).

#### Custom Labels with Yup

With yup it is very straightforward, you just need to call `label()` after defining your field's validations either at the field level or form level:

```js
const schema = Yup.object({
  email_addr: Yup.string().email().required().label('Email Address'),
  acc_password: Yup.string().min(5).required().label('Your Password'),
});
```

#### Custom Labels with Zod

Zod does not have a built-in `label` method, but you can override the default error messages by passing a custom message to the chained validator.

```js
const schema = z.object({
  email_addr: z.string().email({ message: 'Email Address be a valid email address' });
  acc_password: z.string().min(5, { message: 'Password be at least 5 characters long' });
});
```

If you are interested in how to do the same for global validators check the [i18n guide](/guide/i18n#custom-labels)

## Field-level Meta

Each field has metadata associated with it, the `meta` property returned from `useField` contains information about the field:

- `valid`: The current field validity, is automatically updated for you.
- `touched`: If the field was **touched**, can be updated with `setTouched` on `useField`'s return value.
- `dirty`: If the field value was updated, you cannot change its value.
- `pending`: If the field's validations are still running, useful for long-running async validation.
- `initialValue`: The field's initial value, is `undefined` if you didn't specify any.

```js
const { meta } = useField('fieldName');

meta.dirty;
meta.pending;
meta.touched;
meta.valid;
meta.initialValue;
```

This is the typescript interface for a field's meta value

```ts
interface FieldMeta {
  dirty: boolean;
  pending: boolean;
  touched: boolean;
  valid: boolean;
  initialValue: any;
}
```

Just like how the form's `meta` is read-only, this is also read-only and you cannot change it directly. Actually, only the `touched` meta value can be mutated using `handleBlur`, all other meta values are automatically updated for you as the field validates or when it changes its value.

```js
const { meta, handleBlur } = useField('fieldName');

// updates meta.touched = true
handleBlur();
```

<DocTip title="Valid Flag Combinations">

Since the `meta.valid` flag is initially `true` (because it just means there are no errors yet), it would cause problems if you have a "success" UI state as an indicator.

To avoid this case you should combine the `valid` flag with either `meta.dirty` or `meta.touched` to get an accurate representation. You will see that in action in the next example.

</DocTip>

In the following example, we the various meta information flags to style the input with some styling.

<Repl files={{ 'App.vue': 'CompositionCustomField05', 'InputText.vue': 'CustomInputFieldMeta' }} client:visible />

<DocTip title="Field Dirty Flag and Initial Values">

Notice in the previous example, we passed an `initialValue`, this is because the default field value is `undefined` which may cause unexpected `meta.dirty` results.

To get accurate results for the `meta.dirty` flag, you must provide an initial value to your field even if the values are empty.

To reduce the verbosity of adding an `initialValue` prop to each field, you could provide the `initialValues` prop to your `useForm` call instead.

</DocTip>

## Building checkboxes

Checkboxes are a hard type of input to implement, mainly because of the expectations about how it should mutate the form's value. For example, a checkbox can be used to toggle between `true` or `false` values which is common with single checkboxes. But it can also be used in a group to act as a multi-select between multiple options. In that case, it adds or removes its own "checked" value to the group value.

This means checkboxes have three states to maintain:

- It's own checked value. In HTML this is done with the `value` attribute for native `input[type="checkbox"]` elements.
- The current form value and if it is a checkbox group or a single checkbox. This is usually the `modelValue` prop for components.
- Whether it's checked or not, if the checked value equals or is in the form value then it is checked. This should be computed based on the previous fact.

All of this can be hard to wrap your head around. However, `useField` makes this easy as it already handles the nuances of checkboxes.

The `useField` function accepts a `type` option that you can use to tell vee-validate that the input type is a checkbox and also accepts a `checkedValue` option.

```ts
const { handleChange, checked } = useField('myCheckbox', undefined, {
  type: 'checkbox',
  checkedValue: 'opt1',
});
```

A simple integration with an input element would look like this:

<Repl
  files={{ 'App.vue': 'CompositionCustomFieldCheckbox', 'CustomCheckbox.vue': 'CustomCheckboxInputBasic' }}
  client:only
/>

Note that we are not using `v-model` with the `value` returned from `useField` here. This is because `handleChange` is better suited for checkboxes as it handles toggling the value on or off and is also aware of the form has other checkboxes so it also handles whether the value should be an array or a single value.

# Helpers

Aside from `useField` and `useForm` and `useFieldArray`, these are a collection of simple functions that you can use to opt-in specific parts of vee-validate features like form state and various actions you can perform on fields and forms.

Here are a few examples of what you can build with these functions:

- A custom submission progress component
- A custom error message component.
- A form validity indicators
- reset buttons or submit buttons

Here is a list of the functions available that you can use:

- `useFieldError` Gives access to a single field's first error message
- `useFormErrors` Gives access to the entire error bag of the form
- `useIsFieldDirty` If a field is dirty
- `useIsFormDirty` If the form is dirty (form contains at least one dirty field)
- `useIsFieldTouched` If a field is touched
- `useIsFormTouched` If the form is touched (form contains at least one touched field)
- `useIsFieldValid` If a field is valid
- `useIsFormValid` If all fields are **validated and valid**
- `useValidateField` Returns a function that validates a specific field
- `useValidateForm` Returns a function that validates the entire form
- `useResetForm` Resets the form to its initial state
- `useSubmitForm` Creates a submission function that validates and submits the form (even if no `form` element is involved)
- `useIsSubmitting` If the form is currently submitting
- `useIsValidating` If the form is currently validating by validate function
- `useSubmitCount` The number of times the user attempted to submit the form
- `useFieldValue` Returns a specific fields' current value
- `useFormValues` Returns the current form field values

# Typed Schemas

<DocTip type="warn">

This guide is aimed towards TypeScript usage with vee-validate's composition API. If you are using the components API or JavaScript then there isn't much to learn here.

</DocTip>

## Input and Output types

Consider the following form:

```ts
import { useForm } from 'vee-validate';
import { object, string } from 'yup';

const { values, handleSubmit } = useForm({
  validationSchema: object({
    email: string().required(),
    password: string().required(),
    name: string(),
  }),
});
```

When attempting to interact with the `values` you will notice that it is untyped. Meaning you don't get any type hints or checks which makes it less safe to use.

```ts
// 💥 Blows up because `email` is undefined
values.email.endsWith('@gmail.com');
```

Providing an `initialValues` or an interface to `useForm` could help:

```ts
interface MyForm {
  email?: string | null;
  password?: string | null;
}

const { values, handleSubmit } = useForm<MyForm>({
  validationSchema: object({
    email: string().required(),
    password: string().required(),
    name: string(),
  }),
});

// ❌ Type error, which means `values` is type-safe
values.email.endsWith('@gmail.com');
```

But then you will find another problem when using `handleSubmit`:

```ts
handleSubmit(values => {
  // Must be checked, this means submmited values are inaccurate
  if (values.email) {
    values.email.endsWith('@gmail.com');
  }
});
```

Even though you marked your field as `required`, it still uses the same type you provider earlier which will keep the `email` field as nullable. This is what we mean by the "dual nature" of form values.

Form values can exist in two types/versions:

- The **"input"** type which is the one the user is filling/interacting with, it is the one that captures the user input.
- The **"output"** type which is the one the user ends up submitting.

You can tell vee-validate about this information by using the typed schema resolvers available in companion packages.

## Yup

You can use yup as a typed schema with the `@vee-validate/yup` package:

```sh
# npm
npm install @vee-validate/yup
# yarn
yarn add @vee-validate/yup
# pnpm
pnpm add @vee-validate/yup
```

The `@vee-valdiate/yup` package exposes a `toTypedSchema` function that accepts any yup schema. Which then you can pass along to `validationSchema` option on `useForm`.

This makes the form values and submitted values typed automatically and caters for both input and output types of that schema.

```ts
import { useForm } from 'vee-validate';
import { object, string } from 'yup';
import { toTypedSchema } from '@vee-validate/yup';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      email: string().required(),
      password: string().required(),
      name: string(),
    }),
  ),
});

// ❌ Type error, which means `values` is type-safe
values.email.endsWith('@gmail.com');

handleSubmit(submitted => {
  // No errors, because email is required!
  submitted.email.endsWith('@gmail.com');

  // ❌ Type error, because `name` is not required so it could be undefined
  // Means that your fields are now type safe!
  submitted.name.length;
});
```

### Yup default values

You can also define default values on your schema directly and it will be picked up by the form:

```ts
import { useForm } from 'vee-validate';
import { object, string } from 'yup';
import { toTypedSchema } from '@vee-validate/yup';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      email: string().required().default('something@email.com'),
      password: string().required().default(''),
      name: string().default(''),
    }),
  ),
});
```

Your initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.

### Yup transforms

You can also define transforms to cast your fields before submission:

```ts
import { useForm } from 'vee-validate';
import { object, number } from 'yup';
import { toTypedSchema } from '@vee-validate/yup';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      age: number()
        .transform(val => Number(val))
        .required(),
    }),
  ),
});
```

But note that this does not change the input or output types of the casted fields. The cast will only occur when setting the initial value and when the values are submitted in the submission handler.

## Zod

Zod is an excellent library for value validation which mirrors static typing APIs.

In their own words it is a:

> TypeScript-first schema validation with static type inference

You can use zod as a typed schema with the `@vee-validate/zod` package:

```sh
# npm
npm install @vee-validate/zod
# yarn
yarn add @vee-validate/zod
# pnpm
pnpm add @vee-validate/zod
```

The `@vee-valdiate/zod` package exposes a `toTypedSchema` function that accepts any zod schema. Which then you can pass along to `validationSchema` option on `useForm`.

This makes the form values and submitted values typed automatically and caters for both input and output types of that schema.

```ts
import { useForm } from 'vee-validate';
import { object, string } from 'zod';
import { toTypedSchema } from '@vee-validate/zod';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      email: string().min(1, 'required'),
      password: string().min(1, 'required'),
      name: string().optional(),
    }),
  ),
});

// ❌ Type error, which means `values` is type-safe
values.email.endsWith('@gmail.com');

handleSubmit(submitted => {
  // No errors, because email is required!
  submitted.email.endsWith('@gmail.com');

  // ❌ Type error, because `name` is not required so it could be undefined
  // Means that your fields are now type safe!
  submitted.name.length;
});
```

<DocTip title="refine/superRefine">

There is a known issue with Zod's `refine` and `superRefine` not executing whenever some object keys are missing or not filled which is common with forms. This is not an issue with vee-validate as it is a design choice in Zod at the moment. Refer to [this issue](https://github.com/logaretm/vee-validate/issues/4338) for explanations and further reading.

</DocTip>

### Zod default values

You can also define default values on your zod schema directly and it will be picked up by the form:

```ts
import { useForm } from 'vee-validate';
import { object, string } from 'zod';
import { toTypedSchema } from '@vee-validate/zod';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      email: string().default('something@email.com'),
      password: string().default(''),
    }),
  ),
});
```

Your initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.

### Zod preprocess

You can also define preprocessors to cast your fields before submission:

```ts
import { useForm } from 'vee-validate';
import { object, number, preprocess } from 'zod';
import { toTypedSchema } from '@vee-validate/zod';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      age: preprocess(val => Number(val), number()),
    }),
  ),
});

// typed as `unknown` since the source value can be anything
values.age;

handleSubmit(submitted => {
  // will be typed as number because zod made sure it is!
  values.age;
});
```

## Valibot

[Valibot](https://valibot.dev/) is a schema library with bundle size, type safety and developer experience in mind. It is a great alternative to Yup and Zod if bundle size is a concern.

You can use valibot as a typed schema with the `@vee-validate/valibot` package:

```sh
# npm
npm install @vee-validate/valibot
# yarn
yarn add @vee-validate/valibot
# pnpm
pnpm add @vee-validate/valibot
```

The `@vee-valdiate/valibot` package exposes a `toTypedSchema` function that accepts any valibot schema. Which then you can pass along to `validationSchema` option on `useForm`.

This makes the form values and submitted values typed automatically and caters for both input and output types of that schema.

```ts
import { useForm } from 'vee-validate';
import * as v from 'valibot';
import { toTypedSchema } from '@vee-validate/valibot';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    v.object({
      name: v.pipe(v.string()),
      email: v.pipe(v.string() v.nonEmpty('required')),
      password: v.pipe(v.string(), v.minLength(6, 'Must be at least 6 characters')),
    }),
  ),
});

// ❌ Type error, which means `values` is type-safe
values.email.endsWith('@gmail.com');

handleSubmit(submitted => {
  // No errors, because email is required!
  submitted.email.endsWith('@gmail.com');

  // ❌ Type error, because `name` is not required so it could be undefined
  // Means that your fields are now type safe!
  submitted.name.length;
});
```

### Valibot default values

You can also define default values on your schema directly and it will be picked up by the form:

```ts
import { useForm } from 'vee-validate';
import * as v from 'valibot';
import { toTypedSchema } from '@vee-validate/valibot';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    v.object({
      email: v.optional(v.pipe(string(), v.nonEmpty('required')), 'something@email.com'),
      password: v.optional(v.pipe(v.string(), v.nonEmpty('required')), ''),
      name: v.optional(v.string(), ''),
    }),
  ),
});
```

Your initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.

### Valibot transforms

You can also define transforms to cast your fields before submission:

```ts
import { useForm } from 'vee-validate';
import * as v from 'valibot';
import { toTypedSchema } from '@vee-validate/valibot';

const { values, handleSubmit } = useForm({
  validationSchema: toTypedSchema(
    object({
      age: v.pipe(
        v.unknown(),
        v.transform(v => Number(v)),
      ),
    }),
  ),
});
```

But note that this does not change the input or output types of the casted fields. The cast will only occur when setting the initial value and when the values are submitted in the submission handler.

# Composition API Caveats

When using the composition API, there are a few things that are not clear when first starting to use it. This page will contain these topics and help you understand how to workaround or address them.

## Function Field Names with `useField`

You might've noticed that some examples in the docs pass the field name as a function to `useField`:

```js
import { useField } from 'vee-validate';

export default {
  props: {
    name: String,
  },
  setup(props) {
    const { value, errorMessage } = useField(() => props.name);
  },
};
```

This is mainly because the `props` in Vue.js is a reactive object, meaning if you access or destruct any of its properties they will lose the reactivity aspect. Let's say you did the following:

```js
import { useField } from 'vee-validate';

export default {
  props: {
    name: String,
  },
  setup(props) {
    // ❌ Don't do this in custom input components
    const { value, errorMessage } = useField(props.name);
  },
};
```

The implications are that vee-validate is no longer able to tell when the field name changes, which is crucial for syncing values when they do.

A common example where field names change frequently is in a array field where `v-for` loops field names use the index or the iterated value to generate the field name

```vue{4}
<CustomTextField
  v-for="(user, idx) in users"
  :key="user.id"
  :name="`users[${idx}].name`"
></CustomTextField>
```

To address this issue, you need to get a reactive reference to the `name` property. Vue offers a few ways to do this, so you can use any of the following methods:

```js
import { toRef, toRefs, computed } from 'vue';

// ✅ using a function that returns the name
const { value, errorMessage } = useField(() => props.name);

// ✅ using `toRef`
const { value, errorMessage } = useField(toRef(props, 'name'));

// ✅ using `toRefs`
const { name } = toRefs(props);
const { value, errorMessage } = useField(name);

// ✅ using `computed`
const name = computed(() => props.name);
const { value, errorMessage } = useField(name);
```

## Destructing composable

The composition API examples in the docs have always used the left-hand side destructing syntax when assigning component data with any of the composable functions vee-validate offers. To quickly refresh your memory:

```js
const { value } = useField('field');
const { handleChange } = useForm();
const { fields } = useFieldArray('users');
```

This is required by default, because each of these functions assumes you might never need the entire features each one provides and such each state/function is exposed independently as a `Ref` or a `Function`.

This means if you try the following, it won't work as expected when used in your template:

```vue
<script setup>
import { useField, useForm, useFieldArray } from 'vee-validate';

export default {
  setup() {
    const form = useForm();
    const field = useField('field');
    const fieldArray = useFieldArray('users');

    return {
      form,
      field,
      fieldArray,
    };
  },
};
</script>

<template>
  <!-- ❌ Doesn't work -->
  <input v-model="field.value" />

  <!-- ❌ Doesn't work -->
  <pre>{{ form.meta.valid }}</pre>

  <!-- ❌ Doesn't work -->
  <div v-for="item in fieldArray.fields"></div>
</template>
```

This is because the `setup` function doesn't recursively expose the refs inside of these objects. If you prefer to use the composition API like shown above, then you can fix most of the issues by wrapping the function calls with `reactive()`.

```vue
<script setup>
import { reactive } from 'vue';
import { useField, useForm, useFieldArray } from 'vee-validate';

const form = reactive(useForm());
const field = reactive(useField('field'));
const fieldArray = reactive(useFieldArray('users'));
</script>

<template>
  <!-- ❌  Still Doesn't work because it is a writeable computed ref -->
  <input v-model="field.value" />

  <!-- ✅  Works if unwrapped manually -->
  <input v-model="field.value.value" />

  <!-- ✅  Works -->
  <pre>{{ form.meta.valid }}</pre>

  <!-- ✅  Works -->
  <div v-for="item in fieldArray.fields"></div>
</template>
```

You can read more on that behavior in [Vue.js docs](https://vuejs.org/guide/reusability/composables.html#conventions-and-best-practices). Note that once you wrap the composable calls with `reactive` you no longer can destruct them and preserve the reactivity.
